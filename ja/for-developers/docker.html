<!DOCTYPE html>
<!--
/*
 * INTER-Mediator Ver.@@@@2@@@@ Released @@@@1@@@@
 *
 *   by Masayuki Nii  msyk@msyk.net Copyright (c) 2014 Masayuki Nii, All rights reserved.
 *
 *   This project started at the end of 2009.
 *   INTER-Mediator is supplied under MIT License.
 */
-->
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>ソースコードの投稿 - Product Manual - INTER-Mediator</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../../lib/css/normalize.min.css" rel="stylesheet" media="screen">
    <link href="../../lib/css/style.min.css" rel="stylesheet" media="screen">
    <link href="../../lib/css/nav.min.css" rel="stylesheet" media="screen">
    <link rel="stylesheet" href="../../lib/css/styles/tomorrow-night.css">
    <link rel="shortcut icon" href="../images/im-icon.png" type="image/png">
    <link rel="icon" href="../images/im-icon.png" type="image/png">
    <script src="../../lib/pagebuilder-r2.js"></script>
    <script src="../../lib/pagebuilder-r2.php"></script>
    <script src="../../lib/highlight.pack.js"></script>
    <script>
    hljs.initHighlightingOnLoad()
    </script>
</head>

<body class="docs" data-page-title="for-programmers">
    <div class="container clearfix">
        <div class="page-title">
            <h1>Dockerの利用</h1>
        </div>
        <div class="docs-sidebar sticky clearfix">
            <nav>
                <ul id="pageIndex">
                </ul>
            </nav>
        </div>
        <article>
            <section>
                <h1>はじめに</h1>
                <p class="lead">
                    INTER-Mediatorへのソースコードを投稿する場合の手順をまとめておきます。INTER-Mediatorのコミッターや、あるいはバグレポートの1つの方法として、ソースコードの投稿を歓迎します。手順は、Webサイトを利用した、いちばん手軽な方法が中心です。</p>
            </section>
            <section>
                <h1>ソースコード投稿の考え方</h1>
                <p>INTER-Mediatorはオープンソースプロジェクトであり、コミュニティを形成することで、開発が進行する手法を取り入れています。多くの方々によってソースコードがレビューされることで、システム全体が洗練され、セキュリティ的な問題点が解消されることが期待できます。また、新たな機能やバグ修正等のソースコードの投稿を受け付けることで、システムの継続的な進化も期待できます。そのために、INTER-Mediatorでは、GitHubを利用した「Pull Request」によるソースコードの投稿を広く受け付けることとします。</p>
            </section>
            <section>
                <h1>GitHubの組織「INTER-Mediator」</h1>

                <p>INTER-Mediatorは、<a href="https://github.com/INTER-Mediator/">GitHub上に「INTER-Mediator」という名称の組織</a>を作成しており、そこにあるレポジトリが「マスターレポジトリ」となります。コミッターの開発結果はこのマスターレポジトリにまとめられますが、まとめる作業は、INTER-Mediator Directive Committeeのメンバーによって行われます。レポジトリの1つ「INTER-Mediator」は、フレームワーク本体やサンプルプログラムなどのソフトウエア全般がまとめられています。「INTER-Mediator_WebSite」は、INTER-MediatorのWebサイトのソースです。「INTER-Mediator」はForkをしてPull Requestを送る手法を基本とします。「INTER-Mediator_WebSite」はINTER-Mediator Directive Committeeメンバによる書き込み権限を与えることで、Forkをしないで単一のレポジトリでの運用を基本とします。したがって、本文書に書かれた内容は、フレームワーク本体の「INTER-Mediator/INTER-Mediator」というレポジトリの運用方法を記載したものとなります。
                </p>

                <div class="picture"><img style="width:70%; max-width: 1084px" src="/images/shot9809.png" />
                </div>
            </section>
            <section>
                <h1>GitHubアプリケーションを使ったPull Request</h1>
                <p>GitHubはバージョン管理システムのgitをベースにしており、すべてはgitのコマンドでできると言えますが、コマンドでの処理は習得に時間がかかると同時に失敗しやすいということもあります。しかしながら、GitHubは専用アプリケーションをリリースしており、そのアプリケーションを利用することで、ソースコードの投稿を簡単にできるようになっています。ここでは、なるべくGitHubアプリケーションと、GitHubのサイトを利用するということで、ソースコードを取得し、修正後に投稿する流れを説明します。</p>
                <p>組織で管理しているマスターレポジトリは「INTER-Mediator/INTER-Mediator」と記載します。Gitの表記にしたがって「組織名/レポジトリ名」でレポジトリを記述することにします。ここで、GitHubのあるユーザmsykが、INTER-Mediator本体のレポジトリに対して、ソースコードの追加等を行い、その開発結果を投稿しようとします。</p>

                <p>ソースコードの取得を最初に行いますが、その作業を「マスターレポジトリをForkする」などと呼ばれます。Forkにより、レポジトリの複製を自分自身のアカウントの領域に作成をします。マスターレポジトリへの書き込み権限を持つ人は限られていますが、パブリックなプロジェクトなので、逆にソースコードは誰でも取得できます。したがって、GitHubにアカウントがあれば、誰でもForkができることになります。GitHubにユーザmsykでログインをして作成した、ユーザmsykのINTER-Mediatorフレームワーク本体は、「msyk/INTER-Mediator」と記述をします。さらに、現実には、自分のアカウントにあるリモートのレポジトリのクローンを作業者のMac/PCの中にローカルのレポジトリとして作成をします。ソースコードの改変をする前に、まず、ここまでの準備が必要です。概念図は以下のとおりで、左側のマスターレポジトリをForkして、あるユーザのリモートレポジトリを作成し、そのクローンのレポジトリがローカルにあるという状態です。ここで、masterはブランチ名で、「A」はある状態を示します。この後に、ローカルのレポジトリのソースコードを変更した結果、状態が「B」になるというような図が出てきます。</p>

                <div class="picture"><img style="width: 75%" src="/images/git-fig1.png" />
                </div>

                <h3>Forkする</h3>

                <p>Forkをするには、GitHubに自分のアカウント（この場合はmsyk）でログインをします。そして、組織のページに移動して、マスタレポジトリのトップページを表示します。組織のマスターレポジトリは、レポジトリ名が「INTER-Mediator/INTER-Mediator」となっていることから、判別できます。そして、右上にある「Fork」のボタンをクリックします。これだけで、自分の領域にマスターレポジトリの複製のレポジトリが作成されます。なお、単に複製するだけでなく、マスターレポジトリが元々のオリジナルであることもきちんと記録されています。</p>

                <div class="picture"><img style="width:75%;" src="/images/shot9811.png" />
                </div>
                <p>
                    「Fork」ボタンをクリックした後、画面が遷移して、自分自身の複製したレポジトリのページに移動しています。レポジトリ名が「msyk/INTER-Mediator」となっていて、ユーザmsykにINTER-Mediatorというレポジトリが作られたことがわかります。この段階では、マスターと同一のレポジトリです。</p>

                <div class="picture"><img style="width:70%; max-width: 1084px" src="/images/shot9812.png" />
                </div>

                <h3>ローカルにクローンを作成する</h3>
                <p>さらに自分のレポジトリのクローンを自分のMac/PCに作成します。ここで、クローンはコマンドラインで作る方法などいろいろありますが、使用しているパソコンにGitHubアプリケーションをインストールしておけば、レポジトリのページの「Clone in Desktop」のボタンをクリックし、そしてローカルレポジトリを作るフォルダを指定するだけで、作成することができます。</p>

                <div class="picture"><img style="width:70%; max-width: 1084px" src="/images/shot9813.png" />
                </div>

                <p>コマンドラインで作るときには、ローカルレポジトリを作りたいフォルダをカレントフォルダにして、「git clone [レポジトリのURL]」と入力します。レポジトリのURLは、やはりレポジトリのページ右側にある「HTTPS clone URL」の部分のURLを指定しますが、コピーボタンがあるので、URLをコピーし、コマンドライン入力中にペースとすれば良いでしょう。</p>

                <h3>変更結果をPull Requestする</h3>
                <p>自分のローカルのレポジトリ内で、ファイルを修正したとします。その修正処理はmasterでもいいですが、独自に作成したブランチでもかまいません。以下の図では、「readme-file-modify」というローカルのブランチに、変更結果が存在する状態です。そして、GitHubアプリケーションで、ツールバーの右から2つ目のボタンをクリックすることで、Pull Requestを作成します。パネルをクリックすると、右側に「Pull Request」の薄青い背景のパネルが表示されます。ここで、最初のテキストボックスに概要、そして、広いテキストフィールドにはある程度の説明を入力します。</p>

                <div class="picture"><img style="" src="/images/shot9854.png" />
                </div>

                <p>タイトルの直下の部分で、マージを希望する先のマスターレポジトリのブランチを指定してください。右側はローカルで現在選択されているブランチができていて、ここは変更できません。右側はクリックするとドロップダウンリストが表示され、レポジトリを選択できます。ローカルと同じ名前のブランチの場合で、マスターリポジトリにブランチがない場合、そのブランチはマスターレポジトリに作られます。「Send Pull Request」ボタンをクリックします。このPull Requestは、Forkしたレポジトリの元のレポジトリに送り届けられます。</p>

                <div class="picture"><img style="" src="/images/shot9855.png" />
                </div>

                <p>リクエストでは、取り込み先のブランチを選択できます。通常、最終的に変更結果はmasterに統合されるので、完成した機能やあるいはバグの修正となると、masterに統合することでかまいません。一方、機能そのものが一部しか実現していないものの、その結果を他のデベロッパーにも見てもらいたいといった理由があれば、ブランチにPull Requestを送ってください。その後の統合作業については、ディスカッションの上進めましょう。</p>
                <p>Pull Requestが終了するとメッセージが表示され、GitHubのサイトへのリンクも見えています。ここでは#220という番号も見えています。GitHubアプリケーションを使えば、Pull Requestはこのように簡単に作成できます。</p>

                <div class="picture"><img style="" src="/images/shot9856.png" />
                </div>
            </section>
            <section>
                <h1>マスターレポジトリの更新結果の取り込み</h1>
                <p>Pull Requestによって、複数の開発者からのPull Requestが行われると、当然のこととしてマスターレポジトリはどんどん更新され、それぞれのユーザのレポジトリは以前の状態のままになります。Pull Requestを出したユーザは、自分と同じ状態にマスターレポジトリが更新されたので、同一の状態になっています。しかしながら、別のアカウント（以下の図にあるsomeone）が、msykによるPull Requestを発行する前にForkして、自分アカウントにレジストリーを作っていたとしたら、組織のアカウントは状態Bになっても、someoneの方は状態Aのままになります。someoneのレポジトリは状態Bにしたいと考えます。

                    <div class="picture"><img style="width: 75%" src="/images/git-fig6.png" />
                    </div>

                    <p>一時期はGitHubアプリケーションの右上にある「Sync」ボタンをクリックするだけで、自分のローカルのレポジトリを、Forkした元のマスターレポジトリと同じ状態にできましたが、これは「バグ」だったようで、その後にこの作業は自動的にできなくなっています。Syncは、ローカルとその元になっているレポジトリの間だけの同期です。</p>
                    <p>Forkした元のレポジトリの更新結果を受け入れるには、以下のようにコマンドラインで作業をします。コマンドは、カレントディレクトリが、ローカルレポジトリのフォルダのルートになっている状態で入力します。最初のgit remote -vを見ると、自分自身のGitHub上のレポジトリに対してorignという名前が付けられ、加えて、Fork元のレポジトリは、「INTER-Mediator」という名前が付けられています。よくある作業例ではupstremという名前付けが一般的ですが、この「INTER-Mediator」は、GitHubアプリケーションが自動的に定義を加えています。そして、fetchでFork元のレポジトリを取り込んで、現在のブランチ（ここでは、ローカルレポジトリのmasterが選択されているとする）に、Fork元のレポジトリのmasterブランチの更新結果をマージします。</p>

                    <!--
    <div class="picture"><img style="" src="/images/shot9857.png"/></div>
    <div class="picture"><img style="" src="/images/shot9858.png"/></div>
-->

                    <div class="code"><pre><code>$ <strong>git remote -v</strong>
INTER-Mediator  https://github.com/INTER-Mediator/INTER-Mediator.git (fetch)
INTER-Mediator  https://github.com/INTER-Mediator/INTER-Mediator.git (push)
origin  https://github.com/msyk/INTER-Mediator.git (fetch)
origin  https://github.com/msyk/INTER-Mediator.git (push)
$ <strong>git fetch INTER-Mediator</strong>
$ <strong>git merge INTER-Mediator/master</strong>
Updating 757ee4a..e41aabd
Fast-forward
 INTER-Mediator-UnitTest/sha1-test.js |  10 +++++
 LICENSE                              |   4 ++
 dist-docs/License.txt                |  29 ++++++++++++++
 dist-docs/buildup.sh                 |   2 +-
 dist-docs/change_log.txt             |   2 +
 dist-docs/readme.txt                 |   4 +-
 dist-docs/vm-for-trial/index.html    |   8 ++--
 lib/js_lib/sha1.js                   | 185 ----------------------------------------------------------------------------------------
 lib/js_lib/tinySHA1.js               |   1 +
 9 files changed, 53 insertions(+), 192 deletions(-)
 create mode 100644 INTER-Mediator-UnitTest/sha1-test.js
 create mode 100644 LICENSE
 delete mode 100644 lib/js_lib/sha1.js
 create mode 100644 lib/js_lib/tinySHA1.js</code></pre>
                    </div>
            </section>
            <section>
                <h1>GitHubのWebサイトからPull Requestを送る</h1>
                <p>ここまでにGitHubアプリケーションを使用した方法で、投稿から更新結果の受け取りまでを説明しました。ここからは、これらの作業をGitHubアプリケーションを使わないで行う方法を説明します。</p>

                <h3>変更結果を自分のレポジトリにpush</h3>

                <p>Pull RequestをGitHubアプリケーションを使わないで行うには、まず、変更結果を、自分のレポジトリに反映させます。</p>

                <div class="picture"><img style="width: 75%" src="/images/git-fig2.png" />
                </div>
                <p>ローカルのレポジトリであらたなブランチを作ったり、あるいはマスターレポジトリにすでにブランチがある場合には、そのブランチを現在利用するブランチとしてプログラムの追加や変更を行います。ブランチの切り替えは、GitHubアプリケーションのツールバーでBranchesのボタンをクリックし、ブランチの一覧にある右端の▼をクリックして、「Switch to This Branch」を選択します。プログラムの変更を行った後は、GitHubアプリケーションのツールバーでChangesを選択し、CommitとSyncを行います。Syncにより現在のブランチへのpushも行います。</p>

                <p>ローカルのレポジトリではmasterブランチのまま作業をして、それを自分のリモートレポジトリにpushするときに、新たなブランチを作成するの良いでしょう。たとえば、PHPStormで作業をしているのであれば、ブランチに含めたいファイルを選択したり、あるいはルートのフォルダを選択するなどして、VCSメニューからCommit Changesを選択します。するとコミットされるファイルの一覧と、コミットメッセージが見えるダイアログボックスが表示されます。メッセージを書き込んだ上で、Commitボタンにマウスポインタを移動させるとポップアップメニューが出るので「Commit and Push」を選択します。すると、さらにGit Pushと書かれたダイアログボックスが表示されるので、その下の部分のチェックボックスをオンにして、右側のテキストフィールドに、新たなブランチ名をキータイプします。すると、コミット結果が新たなブランチにpushされ、リモートレポジトリにここで入力した名前のブランチが作成されています。</p>

                <div class="picture"><img style="width:70%; max-width: 1084px" src="/images/shot9829.png" />
                </div>
                <div class="picture"><img style="width:70%; max-width: 1084px" src="/images/shot9830.png" />
                </div>
                <h3>Pull Requestの作成</h3>

                <p>ここまでの作業で、変更結果は、自分のリモートレポジトリ側には反映されていますが、これをマスターに反映するためには、Pull Requestをマスターレポジトリに対して要求します。以下の図では、new-funcというブランチに、改変結果が記録されているので、そのブランチをマスターレポジトリへ取り込んでもらうということを示しています。</p>

                <div class="picture"><img style="width: 75%" src="/images/git-fig3.png" />
                </div>
                <p>ここまでの作業で改変した結果は自分自身のリモートレポジトリにあります。自分のアカウントでログインをして、自分のリモートレポジトリのページを開きます。ここで、ファイルリストの上の部分に、薄い黄色の枠で、Your recently pushed branches:という記述があれば、そこにある「Compare &amp; pull request」ボタンをクリックします。もし、出ていないようであれば、ファイルリストの上部の「branch: master」などと書かれいる部分からブランチを選択して、その左の緑色のボタンをクリックして、移動したページで「Create Pull Request」ボタンをクリックします。</p>

                <div class="picture"><img style="width:70%; max-width: 1084px" src="/images/shot9817.png" />
                </div>
                <p>Pull Requestを作成するページになります。ここで、追加した機能の概要などを記載して「Create pull request」ボタンをクリックします。作業はこれだけです。このユーザ側のレポジトリは、マスターリポジトリからForkしたものなので、このPull Requestは、マスターレポジトリ側に送られます。</p>

                <div class="picture"><img style="width:70%; max-width: 1084px" src="/images/shot9818.png" />
                </div>
            </section>
            <section>
                <h1>Pull Requestの受け入れ</h1>

                <p>マスターレポジトリ側での受け入れ作業は、INTER-Mediator Directive Committeeで行います。Pull Requestがあれば、それをいったんマスターレポジトリにpullします。その段階では、リクエストを送ったのと同じブランチ名のものがマスターレポジトリにできあがります。そして、動作の検証やコードのレビューを行います。masterではないブランチでPull Requstがあったものは、masterへマージします。この場合、マスターレポジトリでPull Requestを行い、それを受け入れればmasterに反映されるということになります。</p>

                <div class="picture"><img style="width: 75%" src="/images/git-fig4.png" />
                </div>
                <div class="picture"><img style="width: 75%" src="/images/git-fig5.png" />
                </div>
                <p>受け付けられたPull Requestはマスターレポジトリ側はでは次のように見えます。</p>

                <div class="picture"><img style="width:70%; max-width: 1084px" src="/images/shot9819.png" />
                </div>
            </section>
            <section>
                <h1>マスターレポジトリからの部分的な受け入れ</h1>

                <p>GitHubアプリケーションを使えばSyncによりマスターレジストリの内容を即座にローカルに取り込むことができます。その作業をコマンドだけで行う方法を、以下に記述します。ローカルレポジトリをマスターとは異なる状態で保持する必要がある場合などには、この方法を応用して、必要な更新だけを取り込むようにします。以下、青色で太字が入力するコマンドで、#で始まるグレーの文字は説明です。</p>

                <div class="code"><pre><code><span style="color:gray"># Forkした自分のレポジトリをローカル側にクローンを作る（すでに作成済みなら不要）</span>
$ <strong>git clone https://github.com/msayukinii/INTER-Mediator.git</strong>
Cloning into 'INTER-Mediator'...
remote: Counting objects: 7408, done.
remote: Compressing objects: 100% (2387/2387), done.
remote: Total 7408 (delta 4983), reused 7408 (delta 4983)
Receiving objects: 100% (7408/7408), 8.04 MiB | 1.71 MiB/s, done.
Resolving deltas: 100% (4983/4983), done.
Checking connectivity... done.
<span style="color:gray"># ローカルレポジトリのルートをカレントディレクトリにする</span>
$ <strong>cd INTER-Mediator/</strong>
<span style="color:gray"># 現在、masterブランチが選択されている。自分のレポジトリにはmaster以外に<br/># targeting-generalizationというブランチもあり、ローカル側にもそのブランチはある</span>
$ <strong>git branch -a</strong>
* master
  targeting-generalization
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/targeting-generalization
<span style="color:gray"># リモートレポジトリの一覧を見る。自分のリモートレポジトリが見えている</span>
$ <strong>git remote -v</strong>
origin https://github.com/msayukinii/INTER-Mediator.git (fetch)
origin https://github.com/msayukinii/INTER-Mediator.git (push)
<span style="color:gray"># 新たに、マスターリポジトリをupstreamという名前でローカルリポジトリに登録する</span>
$ <strong>git remote add upstream https://github.com/INTER-Mediator/INTER-Mediator.git</strong>
<span style="color:gray"># originだけでなくupstreamも管理対象のリモートレポジトリとして登録された</span>
$ <strong>git remote -v</strong>
origin https://github.com/msayukinii/INTER-Mediator.git (fetch)
origin https://github.com/msayukinii/INTER-Mediator.git (push)
upstream https://github.com/INTER-Mediator/INTER-Mediator.git (fetch)
upstream https://github.com/INTER-Mediator/INTER-Mediator.git (push)
<span style="color:gray"># upstreamで指定されるレポジトリの内容を取り込む</span>
$ <strong>git fetch upstream</strong>
remote: Counting objects: 13, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 13 (delta 4), reused 7 (delta 3)
Unpacking objects: 100% (13/13), done.
From https://github.com/INTER-Mediator/INTER-Mediator
* [new branch] master -> upstream/master
* [new branch] targeting-generalization -> upstream/targeting-generalization
<span style="color:gray"># remotes/upstreamの2つのブランチが新たに加わった</span>
$ <strong>git branch -a</strong>
* master
  targeting-generalization
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/targeting-generalization
  remotes/upstream/master
  remotes/upstream/targeting-generalization
<span style="color:gray"># upstream/masterを現在のローカルのmasterにマージする。これで、ローカルのmasterは、マスターレポジトリのmasterと同一の内容になった</span>
$ <strong>git merge upstream/master</strong>
Updating 10e5c96..720ff24
Fast-forward
DB_Null.php | 177 +++++++++++++++
INTER-Mediator-Element.js | 27 ---------------
README.md | 2 +-
Samples/templates/definition_file_full.php | 1 +
4 files changed, 179 insertions(+), 28 deletions(-)
create mode 100644 DB_Null.php
<span style="color:gray"># 自分のリモートレポジトリのmasterに、ローカルの内容をpushすることで、リモート側にも反映される。ただし、この作業は必須ではない</span>
$ <strong>git push origin master</strong>
<span style="color:gray"># さらにマスターレポジトリ側の別のブランチを取り込みたいのなら、まず、ローカル側を受け入れるブランチに切り替える</span>
$ <strong>git checkout targeting-generalization</strong>
Switched to branch 'targeting-generalization'
Your branch is ahead of 'origin/targeting-generalization' by 2 commits.
  (use "git push" to publish your local commits)
<span style="color:gray"># すでにマスターレポジトリのブランチは取り込んであるので、マージすれば、このブランチもマスターレポジトリの内容と同じになる</span>
$ <strong>git merge upstream/targeting-generalization</strong>
Already up-to-date!
Merge made by the 'recursive' strategy.</code></pre>
                </div>
                <p>上位の一連のコマンドの流れを図示すると次のようになります。一度、upstreamで参照を作っておけば、以後は、fetchしてmergeすることで、マスターレポジトリの内容をローカルのmasterに取り込むことができます。</p>
                <div class="picture"><img style="width: 75%" src="/images/git-fig7.png" />
                </div>
                <p>最初に前提として「masterが正」であるということを記述しましたが、場合によっては、機能が完成する前にレビューや共同作業目的で、ブランチのPull Requestが発生するかど思われます。そういうブランチはマスターレポジトリに残したままになり、fetchによってupstreamにも取り込まれます。こちらは必要に応じてマージすればいいと思われます。また、共同で新たな機能を作る場合、各自がForkしたレポジトリで作業するのは、更新結果の配布に時間がかかることも予想されます。その場合、共同開発している中の1人のForkしたレポジトリに他の開発者も書き込み権限を与えて登録して、単一のレポジトリで各自がcommit/pushするという開発モデルの方が効率がいいと思われます。</p>
            </section>
        </article>

        <!--  -->
        <article class="markdown-body entry-content" itemprop="text">
          <section>
            <h1>INTER-MediatorをDockerで動かす</h1>
          </section>
          <section>
            <h1>はじめに</h1>
            <h3>Dockerとは</h3>

            <blockquote>
              <p>Docker（ドッカー[2]）はソフトウェアコンテナ内のアプリケーションのデプロイメントを自動化するオープンソースソフトウェアである。
                <a href="https://ja.wikipedia.org/wiki/Docker">Wikipediaより</a>
              </p>
            </blockquote>

            <p>
              Dockerを使うことにより、例えば同じ設定内容のWebサーバーを素早く追加して並列化したり、プロダクション環境と同じWebサーバーを開発環境に用意することが迅速にできます。<br/>
              もちろんWebサーバーに限らずDBサーバーにも使うことが出来ます。<br/>
              ここではそんなDockerをINTER-Mediatorを動かす環境としてセットアップしてみます。
            </p>
          </section>
          <section>
            <h1>Dockerのインストール</h1>

            <h3>Dockerのインストール</h3>
            <p>
              まずはローカルに Docker が実行できる環境を作りましょう。以下のドキュメントを参考にしてください。<br/>
              Mac では Docker Toolbox をインストールする方法と Docker for Mac をインストールする方法の2通りがあります。<br/>
              Windows では Docker Toolbox をインストールする方法と Docker for Windows をインストールする方法の2通りがあります。<br/>
              OSのバージョンによってはインストールの選択肢がDocker Toolboxのみとなります。
            </p>

            <h4>macOSにDockerをセットアップする場合</h4>
            <p>
              macOSの場合、Docker Toolboxを入れる方法とDocker for Macを入れる方法があります。<br/>
              既にVirtualBoxを使用している場合は<a href="https://www.docker.com/products/docker-toolbox">Docker Toolbox</a>をダウンロードしてインストールします(ダウンロードに結構時間がかかるかもしれません...)。<br/>
              仮想化ソフトウェアを一度もインストールしたことがないのでしたらDocker Toolboxを入れてもいいですし、<a href="https://docs.docker.com/docker-for-mac/">Docker for Mac</a>を入れても構いません。<br/>
              ※Docker Toolboxのインストーラの中でVirtualboxのインストールが行われます。<br/>
              <div class="picture"><img style="width:70%; max-width: 70%" src="/images/docker0001.png" /></div>
              Docker for Mac は、macOSのxhyveを使っています。<br/>
              よく分からない場合やxhyveが信用ならない場合はDocker Toolboxでのセットアップを採用してください。<br/>
              ここではDockerの詳しい説明は行いません。
            </p>

            <h4>WindowsにDockerをセットアップする場合</h4>
            <p>
              Windows7(64bit)以降であればWindowsでもDockerを動かすことが出来ます。<br/>
              <a href="https://www.docker.com/products/docker-toolbox">Docker Toolbox</a>のwindows版をインストールします(ダウンロードに結構時間がかかるかもしれません...)。<br/>
              ※Docker Toolboxのインストーラの中でVirtualboxのインストールが行われます。<br/>
              Windows10 Proに限ってはHyper-Vを利用する<a href="https://docs.docker.com/docker-for-windows/">Docker for Windows</a>のインストールが簡単です。<br/>
              ※Docker for Windowsは2016/07/05時点ではWindows 10 Pro、Enterprise、Educationのみ対応ですが将来的には他のWindows10もサポートする予定だそうです。<br/>
              ※Docker for WindowsではHyper-Vを使います。お使いのPCの構成によってはHyper-Vの構成と再起動が入ります。<br/>
              ※Windows用のインストールでウィザード内でKitematicのインストールチェックボックスは外さないようにしてください。後で使います。<br/>
              <div class="picture"><img style="width:70%; max-width: 70%" src="/images/docker0002.png" /></div>
              <div class="picture"><img style="width:70%; max-width: 70%" src="/images/docker0003.png" /></div>
            </p>

            <h4>KitematicでDockerを試す</h4>
            <p>
              Dockerの便利ツールの中にKitematicというものがあります。<br/>
              Dockerのお手軽さを体験するために、Kitematicを使ってみましょう。<br/>
              KitematicはDockerをGUIで操作するツールです。Dockerのインストール時に一緒に入ってるはずです。<br/>
              <div class="picture"><img style="width:70%; max-width: 70%" src="/images/docker0004.png" /></div>
              ※Docker for mac の場合は別途ダウンロードが必要です。ダウンロードしたものをアプリケーションフォルダに入れてください。<br/>
              <div class="picture"><img style="width:50%; max-width: 50%" src="/images/docker0005.png" /></div>
              <div class="picture"><img style="width:70%; max-width: 70%" src="/images/docker0006.png" /></div>
              ※Docker for Windowsの場合は別途ダウンロードが必要な場合があります。ダウンロードしたものを任意の場所に解凍(展開)してください。<br/>
              <div class="picture"><img style="width:50%; max-width: 50%" src="/images/docker0007.png" /></div>
              <div class="picture"><img style="width:50%; max-width: 50%" src="/images/docker0008.png" /></div>
              <div class="picture"><img style="width:70%; max-width: 70%" src="/images/docker0009.png" /></div>
              ※WindowsでDocker Toolboxをインストールした場合でKitematicの最初の起動に失敗した場合、Hyper-Vを使おうとしている時があります、選択肢にVirtualboxを使うがありますので、そちらで再度起動を試してください。<br/>
              Kitematicを起動すると真ん中にDockerHubで公開されているDockerイメージのお薦めなどが表示されています。<br/>
              <div class="picture"><img style="width:80%; max-width: 80%" src="/images/docker0010.png" /></div>
              ここでは検索して任意のDockerイメージを探すことも出来ます。<br/>
              虫眼鏡マークの検索欄に
            </p>

            <pre><code>sakadonohito/im</code></pre>

            <p>
              と入力して検索してみましょう。INTER-Mediatorを動かすDockerのサンプルが出てきます。これをNewしましょう。<br/>
              ローカルにDockerイメージがダウンロードされますのでそれを起動してみましょう。<br/>
              起動したらブラウザでアクセスしてみましょう。<br/>
              http://localhost/im/Samples <br/>
              INTER-MediatorのサンプルTOPページが表示されましたでしょうか。
            </p>
            <p>一体何がどうなったのでしょうか？仕組みを説明します。</p>
            <ol>
              <li>INTGER-Mediatorが動く状態のPHP、MySQL、Apacheが組み込まれたDockerイメージがDockerHubにホストされていた。</li>
              <li>手元の環境にDockerやDockerのGUIツールKitematicをインストールした。</li>
              <li>KitematicからDOckerHubにアクセスし、INTER-MediatorのDockerイメージをダウンロードした。</li>
              <li>KitematicからダウンロードしたDockerイメージを起動した。</li>
              <li>ブラウザから起動したDockerイメージ上のINTER-Mediatorにアクセスした。</li>
            </ol>
            <p>という流れです。<br/>
              なぜ、先述のURLでDocker上のINTER-Mediatorにアクセス出来たのかは、そうなるようにDocker上のApacheの設定を行っているからです。<br/>
              お手軽ですね。
            </p>
          </section>
          <section>
            <h1>IMを動かすDockerイメージの作成</h1>

            <p>
              前の項でKitematicを使って作成済みのDockerイメージを起動することが出来ました。<br/>
              次に自作のINTER-MediatorアプリをDockerイメージ化するにはどうしたらよいでしょうか。<br/>
              簡単に説明します。
            </p>

            <h4>Dockerイメージの設計書？Dockerfile</h4>

            <p>詳しくはDockerの公式を参照して欲しいのですが、<strong>Dockerfile</strong>という名前のテキストファイルに</p>

            <ol>
              <li>ベースとなるLinuxディストリビューションやDockerイメージ名の指定</li>
              <li>作成者の名前</li>
              <li>Dockerイメージにインストールしたいライブラリ等のインストールコマンド、事前に用意したファイルを取り込むコマンドなど</li>
            </ol>

            <p>といった内容を記述します。<br/>
              INTER-Mediator用のイメージを作りには
            </p>

            <ol>
              <li>ベースとなるLinuxディストリビューションやDockerイメージ名の指定</li>
              <li>作成者の名前</li>
              <li>PHPのインストールと設定</li>
              <li>MySQLのインストールと設定</li>
              <li>Apacheのインストールと設定</li>
              <li>INTER-MediatorディレクトリをWeb公開用の場所に配置</li>
            </ol>

            <p>のようになります。<br/>
              終わったら記述したDockerfileからイメージを作成します。<br/>
              Dockerfileのあるディレクトリで以下のようなコマンドでイメージを作成します。<br/>
              <a href="https://github.com/sakadonohito/im-docker/blob/master/Dockerfile">参考Dockerfile</a>
            </p>

            <pre><code>docker build -t &lt;name&gt;/&lt;app&gt;:&lt;tag&gt;</code></pre>

            <p>nameはDockerHubの登録アカウント名、appは今回ならINTER-Mediatorと分かるような名称がいいでしょう。<br/>
              tagはバージョン番号になります。
            </p>

            <p>注意点としては、Dockerは仮想サーバーではありません。Dockerイメージを起動したからといって、自動起動のサービスが勝手に起動したりはしません。<br/>
              Dockerイメージの起動時に渡すコマンドで目的のサービスを起動します。
            </p>

            <p>作成したDockerイメージは例として以下の様なコマンドで起動できます。</p>

            <pre><code>docker run -d --name im -p 18880:80 myhoge/im:1.0</code></pre>

            <p>例はDocker(以降 コンテナ)を「im」という名前でバックグラウンドプロセスで起動。ローカルの18880ポートをコンテナの80ポートにマッピング、Dockerイメージは「myhoge/im:1.0」という意味になります。<br/>
              正しくDockerイメージが作成できていれば http://localhost:18880/ でコンテナ内で起動したApacheのルートが表示されます。
            </p>

            <p>これでいつでも手元でINTER-Mediatorを起動できるようになりました。</p>
          </section>
          <section>
            <h1>DockerHubの登録手順</h1>

            <p>手元でDockerのイメージが作成出来るようになって、ローカルで起動もできるようになりました。<br/>
              このイメージを他の環境でも使いたい場合はどうしたらよいでしょうか？<br/>
              DockerfileをGithubに置いておいて、都度DockerfileをpullしてDockerイメージをbuildして構いません。<br/>
              ですが、作成したイメージをDockerHubに登録しておいて、使いたい環境でpullするのが使う時はお手軽です。
            </p>

            <p>
              <a href="https://hub.docker.com/">Docker Hub</a>にアクセスし、アカウントを持っていない人は登録します。<br/>
              アカウントの登録ができていれば後は手元からDockerイメージをpushするだけです。<br/>
              手元のターミナルで
            </p>

            <pre><code>docker login</code></pre>

            <p>してでまずはターミナルでDockerHubにログインします。次に</p>

            <pre><code>docker push myhoge/im:1.0</code></pre>

            <p>のようにコマンドを入力します。myhoge/im:1.0は前項の例の流用です。<br/>
              dockerイメージ名:tagという構文です。<br/>
              ※latestというtagでイメージを作成してpushした場合はDockerHubからpullする際にtagを省略してDockerイメージをpull出来るようになります。
            </p>
          </section>
          <section>
            <h1>Dockerコンテナの中身を分割する</h1>

            <p>
              1つのDockerイメージに全てを詰め込むのはポータビリティが高いですが、本当はDockerの思想に反します。<br/>
              1つのDockerコンテナには一つの役割にするのが理想とされています。<br/>
              Webサーバー、DBサーバー、さらに分割するなら永続データとコンテナを分けてみましょう。<br/>
              ※PHPをApacheで動かす前提で説明しますので、ここではPHPとWebサーバー(Apache)は分けません。
            </p>

            <h3>docker-composeを使う</h3>

            <p>
              上記のコンテナ分割を行うと、1つのアプリのために幾つものDockerコンテナをセットアップして起動しないといけなくなりちょっと煩雑になります。<br/>
              Dockerにはその煩雑さを解消するため、docker-composeというツールが有りますので、使ってみましょう。<br/>
              Dockerをインストールすると一緒についてきます。<br/>
              ※docker-composeのバージョンが1.7未満の場合はバージョンを上げてください。
            </p>

            <p>
              細かい内容説明はドキュメントを参照してください。完成形をpullしましょう。<br/>
              任意のディレクトリで以下のコマンドを実行し、githubからサンプルのdocker-composeファイルをcloneします。
            </p>

            <pre><code>git clone https://github.com/sakadonohito/im-compose.git </code></pre>

            <p>
              cloneした内容に<strong>docker-compose.yml</strong>という設定ファイルがあります。<br/>
              ここにどういったDockerコンテナの起動に関する設定を連携させたいコンテナ分だけ記述します。<br/>
              YAMLファイルについての説明はここでは割愛します。<br/>
              このdocker-compose.ymlで扱うMySQLとPHP(with Apache)のDocker起動設定を記載しています。<br/>
              また、データボリュームの設定も書いてあります。<br/>
              実はこのcloneした内容には2つ足りないものが有りますので、別途用意してください、
            </p>

            <ul>
              <li>
                INTER-Mediatorで使うMySQLのサンプルデータを流し込むSQLファイル(sample_schema_mysql.sql)
                <ul>
                  <li>INTER-Mediatorをダウンロードした際に内包しているsample_schema_mysql.txtファイルをsample_schema_mysql.sqlに拡張子変更してください。</li>
                  <li>mysql/tmpというディレクトリがない場合は作成してください。</li>
                  <li>sample_schema_mysql.sqlをmysql/tmpディレクトリに配置してください。</li>
                </ul>
              </li>
              <li>
                INTER-Mediatorそのもの。
                <ul>
                  <li>INTER-Mediatorをapache/webrootディレクトリに<em>im</em>という名前に変更して配置してください。</li>
                </ul>
              </li>
            </ul>

            <p>上記の追加作業を行ったら、以下のコマンドを実行してください。</p>

            <pre><code>docker-compose up -d</code></pre>

            <p>設定ファイルの内容に従って、イメージをpullしてデーモンで起動してくれます。<br/>
              <a href="http://192.168.99.100/im/Samples">http://192.168.99.100/im/Samples</a> にアクセスしてみてください。サンプルの画面が見えると思います。<br/>
              今回の設定では、ローカルに配置したINTER-MediatorをDockerコンテナにマウントして使っていますので、ローカル上でINTER-Mediatorを編集すると、それが反映されます。htmlファイルを編集して画面を更新してみてください。
            </p>

            <p>コンテナを停止して削除するには以下のコマンドを実行します。</p>

            <pre><code>docker-compose down -v</code></pre>

            <p>コンテナの停止と削除、それからネットワーク設定とボリュームの削除が行われます。</p>
          </section>
          <section>
            <h1>さいごに</h1>

            <p>
              INTER-MediatorのDockerイメージの作成についての説明は以上になります。<br/>
              さてこうして作成したDockerイメージはどこで使えるのでしょうか？<br/>
              以下の様な使い方ができます。
            </p>

            <ul>
              <li>手元でデモ環境として起動する。</li>
              <li>他の人にINTER-Mediatorを手軽に体験してもらうためにDockerHubに登録しておく</li>
              <li>作成したDockerイメージを本番用Linuxサーバー上で起動して使う</li>
              <li>AWSのElasticBeanstalk上で起動する。</li>
              <li>AWSのElasticContainerService上で起動する。</li>
              <li>HerokuというPaaSサービス上で起動する。</li>
              <li>ArukasというDocker専用のPaaSサービス上で起動する。</li>
              <li>Microsoft Azure上でDockerを起動する。</li>
              <li>Google Cloud Platform上でDockerを起動する。</li>
            </ul>

            <p>
              他にも、開発環境やテスト環境として利用することも可能です。INTER-Mediatorの開発ではCIでDockerを使っているそうです。<br/>
              手軽にINTER-Mediatorを動かす環境としてDockerを是非活用してください。
            </p>
          </section>
        </article>
    </div>
        <!--  -->
    </div>
</body>

</html>
